import * as primitive from './internal/primitives.js';
import { checkInstance, checkStruct, isStatic, symbol_metadata } from './internal/struct.js';
import { capitalize } from './string.js';
export * as Struct from './internal/struct.js';
/**
 * Gets the size in bytes of a type
 */
export function sizeof(type) {
    // primitive
    if (typeof type == 'string') {
        primitive.checkValid(type);
        return (+primitive.normalize(type).match(primitive.regex)[2] / 8);
    }
    checkStruct(type);
    const struct = isStatic(type) ? type : type.constructor;
    return struct[symbol_metadata(struct)][Symbol.struct_metadata].size;
}
/**
 * Returns the offset (in bytes) of a member in a struct.
 */
export function offsetof(type, memberName) {
    checkStruct(type);
    const struct = isStatic(type) ? type : type.constructor;
    const metadata = struct[symbol_metadata(struct)][Symbol.struct_metadata];
    const member = metadata.members.get(memberName);
    if (!member)
        throw new Error('Struct does not have member: ' + memberName);
    return member.offset;
}
/**
 * Aligns a number
 */
export function align(value, alignment) {
    return Math.ceil(value / alignment) * alignment;
}
/**
 * Decorates a class as a struct
 */
export function struct(options = {}) {
    return function _decorateStruct(target, context) {
        context.metadata ??= {};
        context.metadata[Symbol.struct_init] ||= [];
        let size = 0;
        const members = new Map();
        for (const _ of context.metadata[Symbol.struct_init]) {
            const { name, type, length } = _;
            if (!primitive.isValid(type) && !isStatic(type)) {
                throw new TypeError('Not a valid type: ' + type);
            }
            members.set(name, {
                offset: options.isUnion ? 0 : size,
                type: primitive.isValid(type) ? primitive.normalize(type) : type,
                length,
            });
            const memberSize = sizeof(type) * (length || 1);
            size = options.isUnion ? Math.max(size, memberSize) : size + memberSize;
            size = align(size, options.align || 1);
        }
        context.metadata[Symbol.struct_metadata] = { options, members, size };
        return target;
    };
}
/**
 * Decorates a class member to be serialized
 */
export function member(type, length) {
    return function (value, context) {
        let name = context.name;
        if (typeof name == 'symbol') {
            console.warn('Symbol used for struct member name will be coerced to string: ' + name.toString());
            name = name.toString();
        }
        if (!name) {
            throw new ReferenceError('Invalid name for struct member');
        }
        context.metadata ??= {};
        context.metadata[Symbol.struct_init] ||= [];
        context.metadata[Symbol.struct_init].push({ name, type, length });
        return value;
    };
}
/**
 * Serializes a struct into a Uint8Array
 */
export function serialize(instance) {
    checkInstance(instance);
    const { options, members } = instance.constructor[symbol_metadata(instance.constructor)][Symbol.struct_metadata];
    const buffer = new Uint8Array(sizeof(instance));
    const view = new DataView(buffer.buffer);
    // for unions we should write members in ascending last modified order, but we don't have that info.
    for (const [name, { type, length, offset }] of members) {
        for (let i = 0; i < (length || 1); i++) {
            const iOff = offset + sizeof(type) * i;
            let value = length > 0 ? instance[name][i] : instance[name];
            if (typeof value == 'string') {
                value = value.charCodeAt(0);
            }
            if (!primitive.isType(type)) {
                buffer.set(value ? serialize(value) : new Uint8Array(sizeof(type)), iOff);
                continue;
            }
            const fn = `set${capitalize(type)}`;
            if (fn == 'setInt64') {
                view.setBigInt64(iOff, BigInt(value), !options.bigEndian);
                continue;
            }
            if (fn == 'setUint64') {
                view.setBigUint64(iOff, BigInt(value), !options.bigEndian);
                continue;
            }
            if (fn == 'setInt128') {
                view.setBigUint64(iOff + (!options.bigEndian ? 0 : 8), value & primitive.mask64, !options.bigEndian);
                view.setBigInt64(iOff + (!options.bigEndian ? 8 : 0), value >> BigInt(64), !options.bigEndian);
                continue;
            }
            if (fn == 'setUint128') {
                view.setBigUint64(iOff + (!options.bigEndian ? 0 : 8), value & primitive.mask64, !options.bigEndian);
                view.setBigUint64(iOff + (!options.bigEndian ? 8 : 0), value >> BigInt(64), !options.bigEndian);
                continue;
            }
            if (fn == 'setFloat128') {
                view.setFloat64(iOff + (!options.bigEndian ? 0 : 8), Number(value), !options.bigEndian);
                view.setBigUint64(iOff + (!options.bigEndian ? 8 : 0), BigInt(0), !options.bigEndian);
                continue;
            }
            view[fn](iOff, Number(value), !options.bigEndian);
        }
    }
    return buffer;
}
/**
 * Deserializes a struct from a Uint8Array
 */
export function deserialize(instance, _buffer) {
    checkInstance(instance);
    const { options, members } = instance.constructor[symbol_metadata(instance.constructor)][Symbol.struct_metadata];
    const buffer = _buffer instanceof Uint8Array ? _buffer : new Uint8Array('buffer' in _buffer ? _buffer.buffer : _buffer);
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    for (const [name, { type, offset, length }] of members) {
        for (let i = 0; i < (length || 1); i++) {
            let object = length > 0 ? instance[name] : instance;
            const key = length > 0 ? i : name, iOff = offset + sizeof(type) * i;
            if (typeof instance[name] == 'string') {
                instance[name] =
                    instance[name].slice(0, i) + String.fromCharCode(view.getUint8(iOff)) + instance[name].slice(i + 1);
                continue;
            }
            if (!primitive.isType(type)) {
                if (object[key] === null || object[key] === undefined) {
                    continue;
                }
                deserialize(object[key], new Uint8Array(buffer.slice(iOff, iOff + sizeof(type))));
                continue;
            }
            if (length > 0) {
                object ||= [];
            }
            const fn = `get${capitalize(type)}`;
            if (fn == 'getInt64') {
                object[key] = view.getBigInt64(iOff, !options.bigEndian);
                continue;
            }
            if (fn == 'getUint64') {
                object[key] = view.getBigUint64(iOff, !options.bigEndian);
                continue;
            }
            if (fn == 'getInt128') {
                object[key] =
                    (view.getBigInt64(iOff + (!options.bigEndian ? 8 : 0), !options.bigEndian) << BigInt(64))
                        | view.getBigUint64(iOff + (!options.bigEndian ? 0 : 8), !options.bigEndian);
                continue;
            }
            if (fn == 'getUint128') {
                object[key] =
                    (view.getBigUint64(iOff + (!options.bigEndian ? 8 : 0), !options.bigEndian) << BigInt(64))
                        | view.getBigUint64(iOff + (!options.bigEndian ? 0 : 8), !options.bigEndian);
                continue;
            }
            if (fn == 'getFloat128') {
                object[key] = view.getFloat64(iOff + (!options.bigEndian ? 0 : 8), !options.bigEndian);
                continue;
            }
            object[key] = view[fn](iOff, !options.bigEndian);
        }
    }
}
function _member(type) {
    function _structMemberDecorator(valueOrLength, context) {
        if (typeof valueOrLength == 'number') {
            return member(type, valueOrLength);
        }
        return member(type)(valueOrLength, context);
    }
    return _structMemberDecorator;
}
/**
 * Shortcut types
 *
 * Instead of writing `@member(type)` you can write `@types.type`, or `@types.type(length)` for arrays
 */
export const types = Object.fromEntries(primitive.valids.map(t => [t, _member(t)]));
